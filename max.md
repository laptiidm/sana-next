
---

## Як працює твій GraphQL API — простою мовою

1. **Всі запити йдуть на один URL — `/graphql`**, і це завжди POST-запити.
   Тобі потрібно відправити запит у форматі JSON, де є:

   * **query** — сам GraphQL-запит (що саме хочеш отримати або змінити),
   * **variables** — додаткові дані, які підставляються у запит (наприклад, вибір сховища — база даних чи XML).

2. **Контролер (GraphQLController) отримує цей JSON** і розпаковує його у зрозумілий для коду формат.

3. **Він дивиться, яке сховище ти обрав — база даних чи XML** (через змінну `storageType`).

4. **Далі викликається внутрішній механізм — DocumentExecuter**, який:

   * Знає структуру запитів (які поля можна запитувати чи змінювати),
   * Знає, які функції (резолвери) треба виконати, щоб отримати або змінити дані,
   * Виконує ці функції, звертаючись до правильного сховища (через сервіс вибору сховища).

5. **Результат роботи (списки задач, нові дані, чи повідомлення про помилки)** перетворюється у JSON і відправляється назад клієнту.

---

### Основні моменти в алгоритмі

* Запитати можна лише ті поля, що описані в схемі (наприклад, активні задачі, виконані, додати задачу).
* Для кожного запиту чи мутації є своя функція, яка працює з правильним сховищем.
* Ти можеш легко змінити, з яким сховищем працювати — просто вказати це у змінних запиту.
* Якщо виникає помилка, ти можеш налаштувати, щоб отримувати докладний опис помилки (для налагодження).
* Вся логіка розділена — контролер лише приймає і віддає запити, виконавча частина — у резолверах і сховах.

---

### Чому це круто?

* Ти маєш **одну точку входу** для всіх операцій.
* Можна легко додавати нові типи запитів чи змін.
* Легко переключатися між сховищами (XML чи база) без зміни бізнес-логіки.
* Чіткий порядок обробки запиту: прийняти — вибрати сховище — виконати — повернути результат.

---

Якщо хочеш, можу допомогти зробити ще простіше або навести приклад запиту!
