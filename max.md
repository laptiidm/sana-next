Ось короткий зрозумілий виклад, як працює твоє GraphQL-API:

* **Єдина точка входу**
  Усі запити йдуть на один endpoint `/graphql` методом POST. Тіло запиту — це JSON з двома полями:

  1. `query` – сам GraphQL-запит або мутація,
  2. `variables` – об’єкт зі змінними (наприклад, `"storageType": "Database"`).

* **Контролер як “раздатчик”**
  Твоїм запитам відповідає `GraphQLController`. Він:

  1. Розбирає JSON-запит у DTO `GraphQLQuery`.
  2. Конвертує рядкове `"Database"` або `"Xml"` у справжній enum `StorageType`.
  3. Якщо це мутація з новою задачею, перетворює JSON-об’єкт на `TaskModel`.
  4. Викликає унікальний внутрішній механізм – `DocumentExecuter`, який підхоплює схему і виконує резолвери.

* **Схема + резолвери**
  У `TaskSchema` зв’язано два набори полів:

  1. **Query** – `activeTasks` і `completedTasks`, які повертають списки задач із потрібного сховища.
  2. **Mutation** – `addTask` і `markTaskAsDone`, які додають чи оновлюють задачі.
     Для кожного поля вказані аргументи і функції, які дістають репозиторій через `IStorageSelectionService` і викликають потрібний метод.

* **Динамічний вибір сховища**
  За допомогою `IStorageSelectionService` ти вирішуєш, чи працювати з базою даних (DB), чи з XML-файлом. Це налаштовується через змінну `storageType`.

* **Валідація та серіалізація**
  Під час виконання запиту всі аргументи перевіряються на типи (GraphQL екземпляри `InputObjectGraphType` та `EnumerationGraphType`). Після цього результат (або помилки) перетворюється в JSON через `IGraphQLTextSerializer` і повертається клієнтові.

* **Рекомендація**
  Щоб швидко відлагоджувати API, залиш у `ExecuteAsync` прапорець `ExposeExceptions = true` — тоді побачиш повні помилки в JSON. А для продакшену вимикай це, щоб не “засвічувати” внутрішню логіку.

---

Цей потік дає змогу гнучко додавати поля чи мутації в майбутньому, завдяки чіткому розподілу схеми, резолверів і серіалізації.
