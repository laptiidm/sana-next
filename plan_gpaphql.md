
---

## План презентації: Як працює GraphQL API у моєму проєкті

### 1. Вступ

* Мета - керування задачами з двома типами сховищ — база даних і XML
* Основна точка входу — endpoint `/graphql` для обробки всіх запитів ([Route("graphql")])

### 2. Прийом запиту

* Клієнт надсилає POST-запит з GraphQL-запитом у форматі JSON ([ApiController] - очікує JSON як вхідний формат за замовчуванням, хоча не тільки це визначає вхідний формат)
* Формат тіла запиту: поля `query`, `variables`, `operationName` (defined in GraphQLQuery.cs)
* Тип сховища передається не у запиті, а у заголовку HTTP `X-Storage-Type` (HttpContext.Request.Headers["X-Storage-Type"].FirstOrDefault() ... HttpContext as a field from ControllerBase)

### 3. Обробка запиту в GraphQLController

* Серіалізація і десеріалізація JSON через `IGraphQLTextSerializer` (використання Newtonsoft.Json)
* Читання заголовка `X-Storage-Type` і передача його в контекст користувача (GraphQLController : userContext, every query, additional info)
* Виклик `IDocumentExecuter.ExecuteAsync` — основний метод виконання запиту з передачею схеми, змінних, userContext, DI-сервісів

### 4. Схема та резолвери

* Визначення схеми GraphQL (`TaskSchema`), що містить Query і Mutation (TaskSchema.cs inherits Schema)
* Резолвери використовують `IStorageSelectionService`, щоб вибрати правильне сховище (XML чи база даних) на основі `X-Storage-Type` 
    (`.ResolveAsync(async context => ... var storageSelectionService = context.RequestServices.GetRequiredService<IStorageSelectionService>();`)
* Через інтерфейс `ITaskRepository` звернення до сховища абстраговані від конкретної реалізації

### 5. Вибір сховища

* `StorageSelectionService` читає тип сховища із заголовка або сесії
* Через DI отримує конкретний репозиторій (`XmlTaskRepository` або `DbTaskRepository`)
* Забезпечує гнучкість і масштабованість (легко додати нові сховища)

### 6. Асинхронність

* Використання асинхронних методів `ExecuteAsync`, `GetActiveTasksAsync` і т.д. (impr!!!)
* Переваги: не блокується сервер, підтримка одночасних запитів

### 7. Серіалізація результату

* Повернення результату у вигляді JSON, сформованого через `IGraphQLTextSerializer` (`var json = _serializer.Serialize(result);`)
* Обробка помилок у запитах і їх відправка у відповіді

### 8. Відсутність middleware

* Логіка обробки GraphQL-запитів реалізована без додаткових middleware, через контролер
* Простота та контроль

### 9. Підсумок

* Гнучке API з вибором сховища на рівні запиту через заголовки
* Чітка структура: контролер → виконавець → схема → репозиторії
* Легка підтримка і розширення

---


---

### Стислий план презентації: Як працює GraphQL API у моєму проєкті

| Етап                            | Опис                                                               | Мій проєкт (контролер)                                                             | Підхід з middleware                                                                        |
| ------------------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **1. Прийом запиту**            | Клієнт надсилає GraphQL запит через POST з JSON                    | Запит приймає контролер `/graphql`, читає заголовок `X-Storage-Type`               | Middleware перехоплює запит до контролера, наприклад, для аутентифікації чи логіки сховища |
| **2. Обробка запиту**           | Виконання GraphQL-запиту з передачею контексту                     | Контролер десеріалізує, передає заголовок у `userContext`, викликає `ExecuteAsync` | Middleware може змінити контекст або керувати виконанням перед контролером                 |
| **3. Вибір сховища**            | Визначення, яке сховище (XML чи БД) використовувати                | Через `StorageSelectionService` з DI та заголовка запиту                           | Middleware міг би встановити сховище у контекст, контролер просто використовує його        |
| **4. Виконання резолверів**     | Резолвери звертаються до сховища через інтерфейс `ITaskRepository` | Асинхронна робота через DI, репозиторії обираються динамічно                       | Аналогічно, але логіка вибору сховища могла бути винесена у middleware                     |
| **5. Серіалізація і відповідь** | Формування JSON-відповіді з результатом запиту                     | Контролер серіалізує результат через `IGraphQLTextSerializer` і відправляє клієнту | Middleware переважно не займається серіалізацією, це робить контролер                      |

---

### Чому обрав контролер замість middleware?

* **Простота і контроль:** Вся логіка обробки запиту — у одному місці (контролер).
* **Гнучкість:** Легко читати заголовки, передавати в `userContext`, працювати з DI.
* **Прямий доступ:** Краще керування помилками і логування.
* **Middleware** добре підходить для крос-каттингових задач (аутентифікація, кешування), але для специфічної логіки GraphQL контролер — більш прозорий і зручний варіант.

---

---

### ✅ `GraphQLQuery.cs`

**Роль:**
Модель для GraphQL-запиту.
**Містить:**
Поля `Query`, `Variables`, `OperationName` — ті, що приходять у тілі POST-запиту.

---

### ✅ `TaskInputType.cs`

**Роль:**
Опис типу вводу (input) для створення або оновлення задачі у GraphQL.
**Містить:**
Визначення полів, які користувач може передати при мутації (`title`, `dueDate`, тощо).

---

### ✅ `TaskMutation.cs`

**Роль:**
Опис мутацій (операцій змін) у GraphQL.
**Містить:**
Операції для додавання, редагування та видалення задач, з урахуванням вибраного сховища (`X-Storage-Type`).

---

### ✅ `TaskQuery.cs`

**Роль:**
Опис запитів (query) у GraphQL.
**Містить:**
Резолвери для `activeTasks` і `completedTasks`, з вибором сховища на основі заголовка.

---

### ✅ `TaskSchema.cs`

**Роль:**
Формує загальну GraphQL-схему.
**Містить:**
Вказівку, які `Query` і `Mutation` використовуються (`TaskQuery`, `TaskMutation`).

---

### ✅ `TaskType.cs`

**Роль:**
Опис типу задачі (output) у GraphQL.
**Містить:**
Поля, які клієнт може отримати при запиті (`taskId`, `title`, `isDone`, тощо).

---


